
\chapter{Autonomie}
\label{chap:autonomie}


\section{Kurze Einführung ins Segeln}
Bevor man Segelboote Autonom machen kann, muss man erst grob verstehen, wie diese sich Fortbewegen. 
\subsection{Segelstellungen}
Grundsätzlich unterscheidet man in 5 Kurse bzw. Segelstellungen.
\begin{itemize}
    \item Vorwind: Wenn der Wind von Hinten kommt. (\textbf{U})
    \item Im wind: Wenn der Wind von Vorne kommt.
    \item Halbwind: Wenn der Wind von $\pm$ 90$^{\circ}$ zum Boot kommt. (\textbf{U})
    \item Raumschot: Wenn der Wind schräg von hinten kommt. (\textbf{S})
    \item Amwind: Wenn der Wind schräg von vorne kommt. (\textbf{S})
\end{itemize}
% TODO Bild von Segelstellungen
Davon sind alle ausser \textit{Im Wind} besegelbaar. Dies liegt daran, dass wenn der Wind von vorne kommt, dieser nicht vom Segel aufgefangen wird. Dieser Bereich wird als \textit{No Go Zone} bezeichnet und ist je nach Boot $\approx 90^{\circ}$. Auf den anderen Kursen wird das Boot entweder durch das Stossprinzip (\textbf{S}) angetrieben oder durch Umstörmung (\textbf{U}) was sehr Ähnlich wie bei Flügeln von Flugzeugen oder Rotorblättern von Windrädern funktioniert.  
\subsection{Wind}
Es ist Wichtig zwischen dem wahren Wind und dem scheinbaren Wind zu unterscheiden. Der wahre Wind kommt aus der echten Richtung. Wenn man auf die Messdaten eines Stationären Windsensors schaut, wird man den wahren Wind ablesen können. Der Scheinbare Wind hingegen ist ein Zusammensetzung aus dem wahren Wind und dem Fahrtwind. Wenn im Segeln von der Windrichtug gesprochen wird, meint man in der Regel den scheinbaren Wind, da miest nur dieser von Bedeutung ist. 
% TODO Vektor bild mit beiden Pfielen

\section{Software Architektur}
\subsection*{Betriebsystem}
Der Raspberry Pi, welcher für die Autonomie zuständig ist, wird mit der Raspberry Pi OS Linux Distribution betrieben. Linux hat im Gegensatz zu Arduinos, ESPs, etc. hat es den entscheidenden Vorteil, dass es einfach zu bedienen, zu warten und zu erweitern ist. Ebenfalls lässt es sehr einfach über WLAN Fernwarten. 

\subsection*{Docker}
Alle für das Boot geschriebenen Programme laufen in Dockercontainer. Docker ist eine Containerisierungstechnologie, welche es erlaubt, Anwendungen in isolierten Containern virtualisiert auszuführen. Diese Container sind leichtgewichtig und portabel.

\subsection*{Programmiersprache}
Aufgrund des einfachen Prototypen wurde die Prgrammiersprache Python gewählt. Im gegensatz zu sprachen wie C++ oder Rust welche um ein vielfaches performanter wären ist Python sehr langsam. Da die Algorithmen wie später nicht erläuter wird, nicht besonders Komplex sind, macht dies keinen Bedeutenden Unterschied. 


\section{Navigation}
Für dieses Projekt wurden Verschiedene Algorithmen untersucht, welche für diese Anwendung denkbar wären.

\subsection{Deep reinforcement learning}
Deep reinforcement learning ist ein Algorithmus aus der Familie des Maschinellen Lernen. Die Besonderheit hierbei ist, dass dieser keine Trainingsdaten benötigt. Dafür wird ein "Agent" in eine Virtuelle Umgebung gesetzt wobei dieser ein Ziel erfüllen muss uns gewisse Freiheitsgrade zur Bewegung hat. Wenn dieser Agent einen Fortschritt macht, wird dieser belohnt. Macht dieser ein Fehler, wird er bestraft. 
Der Nachteil von diesem Ansatz ist, dass dieser nur begrenzt ausserhalb seiner trainierten Umgebung zurechtweiss und dass die Bewegungen eines Segelboots sehr schwer in einer Virtuellen Umgebung zu simulieren sind.

\subsection{Potential Fields} 
Potential Fields ist ein Algorithmus aus der Familie des Pathfindings.

Artificial potential fields ist ein Algorithmus  welcher einen Weg mit anziehnden und abstossenden Felder findet. Es lässt sich sehr einfach mit elektrischen Feldern vergleichen in dem man sich vorstellt, dass das ein Elektron bzw. Proton sich auf einer Fläche befindet. Das Ziel, sprich der Ort an welches das Boot am Ende sein sollte, übt eine anziehende Kraft aus. Jegliche Hindernisse üben eine Abstossende Kraft aus. Mathematisch lässt sich dies als ein Gradient darstellen, wobei anziehend einen, relativ zum Segelboot, sinkenden Verlauf darstellen und Abstossende einen steigenden verlauf darstellen.

sich für ein Wegpunkte basiertes System entscheiden. Somit gibt es einen klar definierten Anfangspunkt und einen klar definierter Endpunkt. Dies hat den Vorteil, dass so Bereiche welche besonders interessant sind sicher besucht werden, da der genaue weg aufgrund von den limitationen des Segelns nicht im Vorhinein definiert werden kann. \\
Daher muss ein Algorithmus entwickelt werden, welcher trotz Gegenwind einen Punkt erreichen kann. Der folgende Algorithmus wird im Anschluss genauer erläutert

\begin{algorithm}
\caption{Berechne neuen Kurs}
\begin{algorithmic}[1]
\Function{BerechneNeuenKurs}{$\vec{v}_{\text{Boot}}, \vec{v}_{\text{Wind}}, \vec{v}_{\text{Ziel}}$}
    \State $\text{Skalarprodukt} \gets \vec{v}_{\text{Wind}} \cdot \vec{v}_{\text{Boot}}$
    
    \State $\vec{neuerKurs} \gets \vec{v}_{\text{Ziel}}$
    
    \If{$\text{Skalarprodukt} < -0.8$}
        \If{$\vec{v}_{\text{Wind}} \cdot \vec{v}_{\text{Ziel}} > -0.8$}
            \State $\vec{neuerKurs} \gets \vec{v}_{\text{Ziel}}$
            \State \Return \Call{Normalisiere}{$\vec{neuerKurs}$}
        \EndIf
        
        \State $n \gets 0$
        \While{$\vec{v}_{\text{Wind}} \cdot \vec{neuerKurs} < -0.8$ \textbf{und} $n < 1$}
            \State $n \gets n + 0.1$
            \State $\vec{neuerKurs1} \gets \vec{v}_{\text{Ziel}} + n \cdot \begin{bmatrix}0 & -1 \\ 1 & 0\end{bmatrix} \cdot \vec{v}_{\text{Ziel}}$
            \State $\vec{neuerKurs2} \gets \vec{v}_{\text{Ziel}} + n \cdot \begin{bmatrix}-1 & 0 \\ 0 & 1\end{bmatrix} \cdot \vec{v}_{\text{Ziel}}$
            
            \If{$\vec{neuerKurs1} \cdot \vec{v}_{\text{Ziel}} > \vec{neuerKurs2} \cdot \vec{v}_{\text{Ziel}}$}
                \State $\vec{neuerKurs} \gets \vec{neuerKurs1}$
            \Else
                \State $\vec{neuerKurs} \gets \vec{neuerKurs2}$
            \EndIf
        \EndWhile
        
        \State \Return \Call{Normalisiere}{$\vec{neuerKurs}$}
    \EndIf
\EndFunction
\end{algorithmic}
\end{algorithm}
 

\begin{figure}[H]
    \centering
    \includegraphics[width=0.5\linewidth]{algorythmus Vektoren.png}
    \caption{Visualisierung}
    \label{fig:enter-label}
\end{figure}







